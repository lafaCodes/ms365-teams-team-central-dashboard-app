/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";

import {
  app,
  HttpRequest,
  HttpResponseInit,
  InvocationContext,
} from "@azure/functions";
import { Client } from "@microsoft/microsoft-graph-client";
import { TokenCredentialAuthenticationProvider } from "@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials";
import {
  AppCredential,
  AppCredentialAuthConfig,
  OnBehalfOfCredentialAuthConfig,
  OnBehalfOfUserCredential,
} from "@microsoft/teamsfx";

import config from "../config";

// Define an enum called FilesType with four possible values for different types of Microsoft Office files.
enum FilesType {
  WORD = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  EXCEL = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  PPT = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  VISIO = "application/vnd.ms-visio.drawing",
}

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */

/**
 * This function is the entry point for the Azure Function.
 * It handles HTTP requests from the Teams client and calls the appropriate function based on the request parameters.
 *
 * @param {HttpRequest} req - The HTTP request.
 * @param {InvocationContext} context - The Azure Functions context object.
 * @returns {Promise<HttpResponseInit>} - A promise that resolves with the HTTP response.
 */
export async function callGraph(
  req: HttpRequest,
  context: InvocationContext,
): Promise<HttpResponseInit> {
  context.log("HTTP trigger function processed a request.");

  // Initialize response.
  const res: HttpResponseInit = {
    status: 200,
    jsonBody: {},
  };

  // Put an echo into response body.
  res.jsonBody.receivedHTTPRequestBody = req.body || "";

  // Prepare access token.
  const accessToken: string = req.headers
    .get("Authorization")
    ?.replace("Bearer ", "")
    .trim();
  if (!accessToken) {
    return {
      status: 400,
      jsonBody: {
        error: "No access token was found in request header.",
      },
    };
  }

  // Set up the configuration for the OnBehalfOfUserCredential.
  const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
    authorityHost: config.authorityHost,
    clientId: config.clientId,
    tenantId: config.tenantId,
    clientSecret: config.clientSecret,
  };

  let oboCredential: OnBehalfOfUserCredential;
  try {
    // Construct the OnBehalfOfUserCredential using the access token and configuration.
    oboCredential = new OnBehalfOfUserCredential(accessToken, oboAuthConfig);
  } catch (e) {
    context.error(e);
    return {
      status: 500,
      jsonBody: {
        error:
          "Failed to construct OnBehalfOfUserCredential using your accessToken. " +
          "Ensure your function app is configured with the right Azure AD App registration.",
      },
    };
  }

  // Get the graphType, method, and request data from the HTTP request.
  const graphType = req.query.get("graphType");
  const method = req.method;

  try {
    // Call the appropriate function based on the graphType and method.
    const result = await handleRequest(
      oboCredential,
      graphType,
      method,
      req
    );
    res.jsonBody = { ...res.jsonBody, ...result };
  } catch (e) {
    context.error(e);
    return {
      status: 500,
      jsonBody: {
        error: "Failed to process request.",
      },
    };
  }

  return res;
}

/**
 * Handles the request based on the given graphType and method.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {string} graphType - The type of graph to query (e.g. "calendar", "task").
 * @param {string} method - The HTTP method to use (e.g. "GET", "POST").
 * @param {any} req - The request data to use (if applicable).
 * @returns {Promise<any>} - A promise that resolves with the result of the request.
 */
async function handleRequest(
  oboCredential: OnBehalfOfUserCredential,
  graphType: string,
  method: string,
  req: any
): Promise<any> {
  let reqData = method === "POST" ? await req.json() : {};

  // Switch statement to handle different graphType and method combinations
  switch (`${graphType}:${method}`) {
    // If graphType is "calendar" and method is "GET"
    case "calendar:GET": {
      // Call getCalendarEvents function to get calendar events
      const events = await getCalendarEvents(oboCredential);
      return { eventResult: events };
    }
    // If graphType is "task" and method is "GET"
    case "task:GET": {
      // Call getTasksInfo function to get task information
      const tasks = await getTasksInfo(oboCredential);
      return { taskResult: tasks };
    }
    // If graphType is "task" and method is "POST"
    case "task:POST": {
      // Call createTask function to create a new task
      const tasks = await createTask(oboCredential, reqData);
      return { taskResult: tasks };
    }
    // If graphType is "files" and method is "GET"
    case "files:GET": {
      // Call getFiles function to get files
      const files = await getFiles(oboCredential);
      return { filesResult: files };
    }
    // If no matching graphType and method combination is found
    default: {
      throw new Error(`Invalid graphType (${graphType}) or method (${method})`);
    }
  }
}

/**
 * Retrieves the user's calendar events for the current day.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of calendar events.
 */
async function getCalendarEvents(oboCredential: OnBehalfOfUserCredential) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Calendars.Read"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Set the end of the day to 23:59:59.999
  const endOfDay = new Date();
  endOfDay.setUTCHours(23, 59, 59, 999);

  // Get the user's calendar events for the current day
  const { value: calendarValue } = await graphClient
    .api(
      `/me/events?$top=2&$select=subject,bodyPreview,organizer,attendees,start,end,location,onlineMeeting&$filter=start/dateTime ge '${new Date().toUTCString()}' and start/dateTime lt '${endOfDay.toUTCString()}'`
    )
    .get();

  // Map the calendar events to a simpler format
  const calendarItems = calendarValue
    .map(({ start, end, subject, location, onlineMeeting }) => ({
      startTime: start,
      endTime: end,
      title: subject,
      location: location.displayName,
      url: onlineMeeting?.joinUrl,
    }))
    .reverse();

  return calendarItems;
}

/**
 * Retrieves the tasks that are not completed from the user's to-do list.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns {Promise<TaskModel[]>} - A promise that resolves with an array of tasks.
 */
async function getTasksInfo(oboCredential: OnBehalfOfUserCredential) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Tasks.ReadWrite"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Get the user's to-do lists
  const { value: tasklists } = await graphClient.api("/me/todo/lists").get();

  // Get the ID of the first to-do list
  const { id: todoTaskListId } = tasklists[0];

  // Get the tasks from the to-do list that are not completed and limit the results to 3
  const { value: tasksInfo } = await graphClient
    .api(
      `/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`
    )
    .get();

  // Map the tasks to a simpler format
  const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
    id,
    name: title,
    status,
    importance,
    content,
  }));

  return tasks;
}

/**
 * Creates a new task in the user's to-do list and retrieves the tasks that are not completed.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {any} reqData - The request data containing the task title.
 * @returns A promise that resolves with an array of tasks.
 */
async function createTask(
  oboCredential: OnBehalfOfUserCredential,
  reqData: any
) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Tasks.ReadWrite", "User.Read"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Get the user's to-do lists
  const { value: tasklists } = await graphClient.api("/me/todo/lists").get();

  // Get the ID of the first to-do list
  const { id: todoTaskListId } = tasklists[0];

  // Create a new task in the user's to-do list with the provided title
  await graphClient
    .api(`/me/todo/lists/${todoTaskListId}/tasks`)
    .post({ title: reqData.taskTitle });

  // Import the TeamsFx SDK and create a new instance for the app identity
  const authConfig: AppCredentialAuthConfig = {
    authorityHost: config.authorityHost,
    clientId: config.clientId,
    tenantId: config.tenantId,
    clientSecret: config.clientSecret,
  };
  const appCredential: AppCredential = new AppCredential(authConfig);

  // Send an activity notification to the user's Teams activity feed
  sendActivityNotification(appCredential, graphClient);

  // Get the tasks from the to-do list that are not completed and limit the results to 3
  const { value: tasksInfo } = await graphClient
    .api(
      `/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`
    )
    .get();

  // Map the tasks to a simpler format
  const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
    id,
    name: title,
    status,
    importance,
    content,
  }));

  return tasks;
}

/**
 * Sends an activity notification to the user's Teams activity feed.
 *
 * @param {TeamsFx} teamsfxApp - The TeamsFx instance for the app identity.
 * @param {Client} graphClient - The Microsoft Graph client.
 */
async function sendActivityNotification(
  appCredential: AppCredential,
  graphClient: Client
) {
  try {
    // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
    const authProvider = new TokenCredentialAuthenticationProvider(
      appCredential,
      {
        scopes: ["https://graph.microsoft.com/.default"],
      }
    );
    let appGraphClient: Client = Client.initWithMiddleware({
      authProvider: authProvider,
    });

    // Get user ID
    const userProfile = await graphClient.api("/me").get();
    const userId = userProfile["id"];

    // Construct the API path to retrieve the app installation information
    const apiPath = `/users/${userId}/teamwork/installedApps?$expand=teamsApp,teamsAppDefinition&$filter=teamsApp/externalId eq '${config.teamsAppId}'`;
    const appInstallationInfo = await appGraphClient.api(apiPath).get();

    // Extract the installation ID from the app installation info
    const appArray = appInstallationInfo["value"][0];
    const installationId = appArray["id"];

    // Create the post body for the activity notification
    let postbody = {
      topic: {
        source: "entityUrl",
        value: `https://graph.microsoft.com/v1.0/users/${userId}/teamwork/installedApps/${installationId}`,
      },
      activityType: "taskCreated",
      previewText: {
        content: "Task Created",
      },
    };

    // Send the activity notification to the user's Teams activity feed
    await appGraphClient
      .api("users/" + userId + "/teamwork/sendActivityNotification")
      .post(postbody);
  } catch (error) {
    console.error("sendActivityNotification error: ", error);
  }
}

/**
 * Retrieves the user's recently accessed files.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of files.
 */
async function getFiles(oboCredential: OnBehalfOfUserCredential) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Calendars.Read"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Get the user's recently accessed files
  const { value: driveInfo } = await graphClient
    .api(
      "/me/drive/recent?$top=5&$select=id,name,webUrl,createdBy,lastModifiedBy,remoteItem"
    )
    .get();

  // Map the files to a simpler format
  const returnAnswer = driveInfo.map(
    ({
      id,
      name,
      remoteItem: {
        createdBy,
        lastModifiedBy,
        createdDateTime,
        lastModifiedDateTime,
        file: { mimeType },
        webDavUrl,
        sharepointIds,
      },
      webUrl,
    }) => ({
      id,
      name,
      createdBy: createdBy.user.displayName,
      lastModifiedBy: lastModifiedBy.user.displayName,
      createdDateTime,
      lastModifiedDateTime,
      type: mimeType,
      weburl: webUrl,
      webDavurl: webDavUrl,
      teamsurl: generateTeamsUrl({
        webUrl,
        mimeType,
        webDavUrl,
        sharepointIds: sharepointIds.siteUrl,
      }),
    })
  );

  return returnAnswer;
}

/**
 * Generates a Teams URL for a file.
 *
 * @param {Object} param0 - The file information.
 * @returns {string} - The Teams URL.
 */
function generateTeamsUrl({
  webUrl,
  mimeType,
  webDavUrl,
  sharepointIds,
}): string {
  let url = "https://teams.microsoft.com/l/file/";

  // Get the file ID from the web URL
  const fileIdStartIndex = webUrl.indexOf("sourcedoc=%7B") + 13;
  const fileIdEndIndex = webUrl.indexOf("%7D");
  const fileId = webUrl.substring(fileIdStartIndex, fileIdEndIndex);
  url += fileId + "?";

  // Get the file type from the MIME type
  let fileTypeString = "";
  switch (mimeType) {
    case FilesType.WORD:
      fileTypeString = "docx";
      break;
    case FilesType.EXCEL:
      fileTypeString = "xlsx";
      break;
    case FilesType.PPT:
      fileTypeString = "pptx";
      break;
    case FilesType.VISIO:
      fileTypeString = "vsd";
      break;
    default:
      fileTypeString = mimeType.substring(
        mimeType.indexOf("application/" + 12)
      );
      break;
  }
  url += "fileType=" + fileTypeString;

  // Encode the object URL and add it to the URL
  const encodedObjectURL = webDavUrl.replace(/:/g, "%3A").replace(/\//g, "%2F");
  url += "&objectUrl=" + encodedObjectURL;

  // Encode the base URL and add it to the URL
  const encodedBaseUrl = sharepointIds
    .replace(/:/g, "%3A")
    .replace(/\//g, "%2F");
  url += "&baseUrl=" + encodedBaseUrl;

  return url;
}

app.http("callGraph", {
  methods: ["GET", "POST"],
  authLevel: "anonymous",
  handler: callGraph,
});
